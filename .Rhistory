distinct(Item, Scale) %>%
arrange(Scale, Item)
}
split_items_by_scale <- function(item_info_adults) {
make_scale_map(item_info_adults) %>%
group_split(scale, .keep = TRUE) %>%
set_names(map_chr(., ~ unique(.x$scale))) %>%
map(~ .x$item)
}
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,
scoring_info      = scoring_info,
id_col            = NULL   # or "participant_id" if you have one
)
make_scale_map <- function(item_info_adults) {
item_info_adults %>%
distinct(Item, Scale) %>%
arrange(Scale, Item)
}
split_items_by_scale <- function(item_info_adults) {
make_scale_map(item_info_adults) %>%
group_split(scale, .keep = TRUE) %>%
set_names(map_chr(., ~ unique(.x$scale))) %>%
map(~ .x$Item)
}
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,
scoring_info      = scoring_info,
id_col            = NULL   # or "participant_id" if you have one
)
missing_in_map   <- setdiff(names(dat_adults), item_map$Item)
source(file.path(function_path, "check_ranges.R"))
#--- Helper: build & cache the item→scale map so you don't keep joining repeatedly
make_scale_map <- function(item_info_adults) {
item_info_adults %>%
distinct(Item, Scale) %>%
arrange(Scale, Item)
}
split_items_by_scale <- function(item_info_adults) {
make_scale_map(item_info_adults) %>%
group_split(scale, .keep = TRUE) %>%
set_names(map_chr(., ~ unique(.x$scale))) %>%
map(~ .x$Item)
}
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,
scoring_info      = scoring_info,
id_col            = NULL   # or "participant_id" if you have one
)
library(stringr)
#--- Helper: build & cache the item→scale map so you don't keep joining repeatedly
make_scale_map <- function(item_info_adults) {
item_info_adults %>%
distinct(Item, Scale) %>%
arrange(Scale, Item)
}
split_items_by_scale <- function(item_info_adults) {
make_scale_map(item_info_adults) %>%
group_split(scale, .keep = TRUE) %>%
set_names(map_chr(., ~ unique(.x$scale))) %>%
map(~ .x$Item)
}
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,
scoring_info      = scoring_info,
id_col            = NULL   # or "participant_id" if you have one
)
View(dat_adults)
dat_adults[20:50]
names(dat_adults)[20:50]
names(dat_adults)[50:150]
names(dat_adults)[50:250]
if (!require("readxl"))    { install.packages("readxl")}; library(readxl)
if (!require("purrr")){ install.packages("purrr")}; library(purrr)
if (!require("stringr")){ install.packages("stringr")}; library(stringr)
if (!require("rlang")){ install.packages("rlang")}; library(rlang)
source(file.path(function_path, "check_ranges.R"))
# Canonical key: strip all non-alphanumerics, lowercase
.canon_key <- function(x) {
x %>%
tolower() %>%
gsub("[^a-z0-9]+", "", ., perl = TRUE)
}
# Normalize an Item/Scale table to columns: item, scale, item_key
.normalize_item_info <- function(item_info_adults) {
ii <- item_info_adults %>%
rename_with(~ "item",  matches("^item$",  ignore_case = TRUE)) %>%
rename_with(~ "scale", matches("^scale$", ignore_case = TRUE)) %>%
mutate(
item  = as.character(item),
scale = as.character(scale),
item_key = .canon_key(item)
) %>%
distinct(item, scale, item_key)
# sanity: warn if duplicate keys map to different items
dup_keys <- ii %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_keys) > 0) {
warning("Multiple Item names collapse to the same canonical key: ",
paste0(dup_keys$item_key, collapse = ", "),
". Disambiguate Item names if this is unintended.")
}
ii
}
# Normalize scoring_info to columns: scale, min, max
.normalize_scoring_info <- function(scoring_info) {
scoring_info %>%
rename_with(~ "scale", matches("^scale$", ignore_case = TRUE)) %>%
rename_with(~ "min",   matches("^min$",   ignore_case = TRUE)) %>%
rename_with(~ "max",   matches("^max$",   ignore_case = TRUE)) %>%
mutate(scale = as.character(scale)) %>%
select(scale, min, max)
}
# Build the link between Item names and actual dat_adults column names,
# handling bracket/dot/etc. mismatches via canonical keys.
.build_item_link <- function(dat_adults, item_info_adults) {
ii <- .normalize_item_info(item_info_adults)
dat_cols <- tibble(
data_col = names(dat_adults),
item_key = .canon_key(names(dat_adults))
)
link <- ii %>%
left_join(dat_cols, by = "item_key")
# items present vs. missing in dat
present  <- link %>% filter(!is.na(data_col))
missing  <- link %>% filter(is.na(data_col))
# sanity: warn if multiple data columns collapse to same key
dup_dat_keys <- dat_cols %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_dat_keys) > 0) {
warning("Multiple data columns collapse to the same canonical key: ",
paste0(dup_dat_keys$item_key, collapse = ", "),
". Consider cleaning column names to avoid ambiguity.")
}
list(link = link, present = present, missing = missing)
}
source(file.path(function_path, "aggregate_scales.R"))
source(file.path(function_path, "extract_scales.R"))
# 0) (Optional) Quick look at mismatch resolution
# items listed in mapping but not found in dat will be warned by check_ranges()
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,  # columns: Item, Scale (any case OK)
scoring_info      = scoring_info,      # columns: scale/min/max (any case OK)
id_col            = NULL               # or "participant_id" if you have one
)
source(file.path(function_path, "check_ranges.R"))
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,  # columns: Item, Scale (any case OK)
scoring_info      = scoring_info,      # columns: scale/min/max (any case OK)
id_col            = NULL               # or "participant_id" if you have one
)
# Canonical key: strip all non-alphanumerics, lowercase
.canon_key <- function(x) {
x %>%
tolower() %>%
gsub("[^a-z0-9]+", "", ., perl = TRUE)
}
# Normalize an Item/Scale table to columns: item, scale, item_key
.normalize_item_info <- function(item_info_adults) {
ii <- item_info_adults %>%
rename_with(~ "item",  matches("^item$",  ignore_case = TRUE)) %>%
rename_with(~ "scale", matches("^scale$", ignore_case = TRUE)) %>%
mutate(
item  = as.character(item),
scale = as.character(scale),
item_key = .canon_key(item)
) %>%
distinct(item, scale, item_key)
# sanity: warn if duplicate keys map to different items
dup_keys <- ii %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_keys) > 0) {
warning("Multiple Item names collapse to the same canonical key: ",
paste0(dup_keys$item_key, collapse = ", "),
". Disambiguate Item names if this is unintended.")
}
ii
}
# Normalize scoring_info to columns: scale, min, max
.normalize_scoring_info <- function(scoring_info) {
scoring_info %>%
rename_with(~ "scale", matches("^scale$", ignore_case = TRUE)) %>%
rename_with(~ "min",   matches("^min$",   ignore_case = TRUE)) %>%
rename_with(~ "max",   matches("^max$",   ignore_case = TRUE)) %>%
mutate(scale = as.character(scale)) %>%
select(scale, min, max)
}
# Build the link between Item names and actual dat_adults column names,
# handling bracket/dot/etc. mismatches via canonical keys.
.build_item_link <- function(dat_adults, item_info_adults) {
ii <- .normalize_item_info(item_info_adults)
dat_cols <- tibble(
data_col = names(dat_adults),
item_key = .canon_key(names(dat_adults))
)
link <- ii %>%
left_join(dat_cols, by = "item_key")
# items present vs. missing in dat
present  <- link %>% filter(!is.na(data_col))
missing  <- link %>% filter(is.na(data_col))
# sanity: warn if multiple data columns collapse to same key
dup_dat_keys <- dat_cols %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_dat_keys) > 0) {
warning("Multiple data columns collapse to the same canonical key: ",
paste0(dup_dat_keys$item_key, collapse = ", "),
". Consider cleaning column names to avoid ambiguity.")
}
list(link = link, present = present, missing = missing)
}
# 0) (Optional) Quick look at mismatch resolution
# items listed in mapping but not found in dat will be warned by check_ranges()
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,  # columns: Item, Scale (any case OK)
scoring_info      = scoring_info,      # columns: scale/min/max (any case OK)
id_col            = NULL               # or "participant_id" if you have one
)
## Data Sanity Check -----------------------------------------
# Canonical key: strip all non-alphanumerics, lowercase
.canon_key <- function(x) {
x %>%
tolower() %>%
gsub("[^a-z0-9]+", "", ., perl = TRUE)
}
# Normalize an Item/Scale table to columns: item, scale, item_key
.normalize_item_info <- function(item_info_adults) {
ii <- item_info_adults %>%
rename_with(~ "item",  matches("(?i)^item$",  ignore_case = TRUE)) %>%
rename_with(~ "scale", matches("(?i)^scale$", ignore_case = TRUE)) %>%
mutate(
item  = as.character(item),
scale = as.character(scale),
item_key = .canon_key(item)
) %>%
distinct(item, scale, item_key)
# sanity: warn if duplicate keys map to different items
dup_keys <- ii %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_keys) > 0) {
warning("Multiple Item names collapse to the same canonical key: ",
paste0(dup_keys$item_key, collapse = ", "),
". Disambiguate Item names if this is unintended.")
}
ii
}
# Normalize scoring_info to columns: scale, min, max
.normalize_scoring_info <- function(scoring_info) {
scoring_info %>%
rename_with(~ "scale", matches("(?i)^scale$", ignore_case = TRUE)) %>%
rename_with(~ "min",   matches("(?i)^min$",   ignore_case = TRUE)) %>%
rename_with(~ "max",   matches("(?i)^max$",   ignore_case = TRUE)) %>%
mutate(scale = as.character(scale)) %>%
select(scale, min, max)
}
# Build the link between Item names and actual dat_adults column names,
# handling bracket/dot/etc. mismatches via canonical keys.
.build_item_link <- function(dat_adults, item_info_adults) {
ii <- .normalize_item_info(item_info_adults)
dat_cols <- tibble(
data_col = names(dat_adults),
item_key = .canon_key(names(dat_adults))
)
link <- ii %>%
left_join(dat_cols, by = "item_key")
# items present vs. missing in dat
present  <- link %>% filter(!is.na(data_col))
missing  <- link %>% filter(is.na(data_col))
# sanity: warn if multiple data columns collapse to same key
dup_dat_keys <- dat_cols %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_dat_keys) > 0) {
warning("Multiple data columns collapse to the same canonical key: ",
paste0(dup_dat_keys$item_key, collapse = ", "),
". Consider cleaning column names to avoid ambiguity.")
}
list(link = link, present = present, missing = missing)
}
# 0) (Optional) Quick look at mismatch resolution
# items listed in mapping but not found in dat will be warned by check_ranges()
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,  # columns: Item, Scale (any case OK)
scoring_info      = scoring_info,      # columns: scale/min/max (any case OK)
id_col            = NULL               # or "participant_id" if you have one
)
## Data Sanity Check -----------------------------------------
# Canonical key: strip all non-alphanumerics, lowercase
.canon_key <- function(x) {
x %>%
tolower() %>%
gsub("[^a-z0-9]+", "", ., perl = TRUE)
}
# Normalize an Item/Scale table to columns: item, scale, item_key
.normalize_item_info <- function(item_info_adults) {
ii <- item_info_adults %>%
rename_with(~ "item",  dplyr::matches("(?i)^item$",  ignore_case = TRUE)) %>%
rename_with(~ "scale", dplyr::matches("(?i)^scale$", ignore_case = TRUE)) %>%
mutate(
item  = as.character(item),
scale = as.character(scale),
item_key = .canon_key(item)
) %>%
distinct(item, scale, item_key)
# sanity: warn if duplicate keys map to different items
dup_keys <- ii %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_keys) > 0) {
warning("Multiple Item names collapse to the same canonical key: ",
paste0(dup_keys$item_key, collapse = ", "),
". Disambiguate Item names if this is unintended.")
}
ii
}
# Normalize scoring_info to columns: scale, min, max
.normalize_scoring_info <- function(scoring_info) {
scoring_info %>%
rename_with(~ "scale", dplyr::matches("(?i)^scale$", ignore_case = TRUE)) %>%
rename_with(~ "min",   dplyr::matches("(?i)^min$",   ignore_case = TRUE)) %>%
rename_with(~ "max",   dplyr::matches("(?i)^max$",   ignore_case = TRUE)) %>%
mutate(scale = as.character(scale)) %>%
select(scale, min, max)
}
# Build the link between Item names and actual dat_adults column names,
# handling bracket/dot/etc. mismatches via canonical keys.
.build_item_link <- function(dat_adults, item_info_adults) {
ii <- .normalize_item_info(item_info_adults)
dat_cols <- tibble(
data_col = names(dat_adults),
item_key = .canon_key(names(dat_adults))
)
link <- ii %>%
left_join(dat_cols, by = "item_key")
# items present vs. missing in dat
present  <- link %>% filter(!is.na(data_col))
missing  <- link %>% filter(is.na(data_col))
# sanity: warn if multiple data columns collapse to same key
dup_dat_keys <- dat_cols %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_dat_keys) > 0) {
warning("Multiple data columns collapse to the same canonical key: ",
paste0(dup_dat_keys$item_key, collapse = ", "),
". Consider cleaning column names to avoid ambiguity.")
}
list(link = link, present = present, missing = missing)
}
# 0) (Optional) Quick look at mismatch resolution
# items listed in mapping but not found in dat will be warned by check_ranges()
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,  # columns: Item, Scale (any case OK)
scoring_info      = scoring_info,      # columns: scale/min/max (any case OK)
id_col            = NULL               # or "participant_id" if you have one
)
# Canonical key: strip all non-alphanumerics, lowercase
.canon_key <- function(x) {
x %>%
tolower() %>%
gsub("[^a-z0-9]+", "", ., perl = TRUE)
}
# Normalize an Item/Scale table to columns: item, scale, item_key
.normalize_item_info <- function(item_info_adults) {
ii <- item_info_adults %>%
rename_with(~ "item",  dplyr::matches("(?i)^item$")) %>%
rename_with(~ "scale", dplyr::matches("(?i)^scale$")) %>%
mutate(
item  = as.character(item),
scale = as.character(scale),
item_key = .canon_key(item)
) %>%
distinct(item, scale, item_key)
# sanity: warn if duplicate keys map to different items
dup_keys <- ii %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_keys) > 0) {
warning("Multiple Item names collapse to the same canonical key: ",
paste0(dup_keys$item_key, collapse = ", "),
". Disambiguate Item names if this is unintended.")
}
ii
}
# Normalize scoring_info to columns: scale, min, max
.normalize_scoring_info <- function(scoring_info) {
scoring_info %>%
rename_with(~ "scale", dplyr::matches("(?i)^scale$")) %>%
rename_with(~ "min",   dplyr::matches("(?i)^min$")) %>%
rename_with(~ "max",   dplyr::matches("(?i)^max$")) %>%
mutate(scale = as.character(scale)) %>%
select(scale, min, max)
}
# Build the link between Item names and actual dat_adults column names,
# handling bracket/dot/etc. mismatches via canonical keys.
.build_item_link <- function(dat_adults, item_info_adults) {
ii <- .normalize_item_info(item_info_adults)
dat_cols <- tibble(
data_col = names(dat_adults),
item_key = .canon_key(names(dat_adults))
)
link <- ii %>%
left_join(dat_cols, by = "item_key")
# items present vs. missing in dat
present  <- link %>% filter(!is.na(data_col))
missing  <- link %>% filter(is.na(data_col))
# sanity: warn if multiple data columns collapse to same key
dup_dat_keys <- dat_cols %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_dat_keys) > 0) {
warning("Multiple data columns collapse to the same canonical key: ",
paste0(dup_dat_keys$item_key, collapse = ", "),
". Consider cleaning column names to avoid ambiguity.")
}
list(link = link, present = present, missing = missing)
}
# 0) (Optional) Quick look at mismatch resolution
# items listed in mapping but not found in dat will be warned by check_ranges()
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,  # columns: Item, Scale (any case OK)
scoring_info      = scoring_info,      # columns: scale/min/max (any case OK)
id_col            = NULL               # or "participant_id" if you have one
)
rlang::last_trace()
source(file.path(function_path, "check_ranges.R"))
# Canonical key: strip all non-alphanumerics, lowercase
.canon_key <- function(x) {
x %>%
tolower() %>%
gsub("[^a-z0-9]+", "", ., perl = TRUE)
}
# Normalize an Item/Scale table to columns: item, scale, item_key
.normalize_item_info <- function(item_info_adults) {
ii <- item_info_adults %>%
rename_with(~ "item",  dplyr::matches("(?i)^item$")) %>%
rename_with(~ "scale", dplyr::matches("(?i)^scale$")) %>%
mutate(
item  = as.character(item),
scale = as.character(scale),
item_key = .canon_key(item)
) %>%
distinct(item, scale, item_key)
# sanity: warn if duplicate keys map to different items
dup_keys <- ii %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_keys) > 0) {
warning("Multiple Item names collapse to the same canonical key: ",
paste0(dup_keys$item_key, collapse = ", "),
". Disambiguate Item names if this is unintended.")
}
ii
}
# Normalize scoring_info to columns: scale, min, max
.normalize_scoring_info <- function(scoring_info) {
scoring_info %>%
rename_with(~ "scale", dplyr::matches("(?i)^scale$")) %>%
rename_with(~ "min",   dplyr::matches("(?i)^min$")) %>%
rename_with(~ "max",   dplyr::matches("(?i)^max$")) %>%
mutate(scale = as.character(scale)) %>%
select(scale, min, max)
}
# Build the link between Item names and actual dat_adults column names,
# handling bracket/dot/etc. mismatches via canonical keys.
.build_item_link <- function(dat_adults, item_info_adults) {
ii <- .normalize_item_info(item_info_adults)
dat_cols <- tibble(
data_col = names(dat_adults),
item_key = .canon_key(names(dat_adults))
)
link <- ii %>%
left_join(dat_cols, by = "item_key")
# items present vs. missing in dat
present  <- link %>% filter(!is.na(data_col))
missing  <- link %>% filter(is.na(data_col))
# sanity: warn if multiple data columns collapse to same key
dup_dat_keys <- dat_cols %>% count(item_key) %>% filter(n > 1)
if (nrow(dup_dat_keys) > 0) {
warning("Multiple data columns collapse to the same canonical key: ",
paste0(dup_dat_keys$item_key, collapse = ", "),
". Consider cleaning column names to avoid ambiguity.")
}
list(link = link, present = present, missing = missing)
}
# 0) (Optional) Quick look at mismatch resolution
# items listed in mapping but not found in dat will be warned by check_ranges()
# 1) Validate ranges & missingness
qc <- check_ranges(
dat_adults        = dat_adults,
item_info_adults  = item_info_adults,  # columns: Item, Scale (any case OK)
scoring_info      = scoring_info,      # columns: scale/min/max (any case OK)
id_col            = NULL               # or "participant_id" if you have one
)
qc$violations   # item, scale, row, value, min, max, direction
qc$missing      # item, scale, row where value is missing or non-numeric
qc$summary      # quick per-scale counts
qc$notes        # which Items weren’t matched to dat; extra columns ignored
# 2) Reuse “items → scales” without repeating steps
scales_list <- extract_scales(dat_adults, item_info_adults)
# e.g., work with one scale:
# anxiety_items <- scales_list[["Anxiety"]]
# 3) Compute per-scale scores (mean by default) for each observation
scale_scores <- aggregate_scales(
dat_adults       = dat_adults,
item_info_adults = item_info_adults,
id_col           = NULL,       # or your ID col
fun              = mean,       # median, sum, custom function etc.
na.rm            = TRUE,
min_items        = 2           # require at least 2 answered items to score
)

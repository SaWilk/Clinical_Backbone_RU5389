pilot_asc_7 <- c()
pilot_ch_6 <- c(62973, 62980, 62998, 62992, 62987, 62989, 62994, 62970)
pilot_ad_all <- c(pilot_ad_2, pilot_ad_9, pilot_ad_8, pilots_ad_auto)
pilot_asc_all <- c(pilots_asc_auto)
pilots_ch_all <- c(pilots_ch_auto, pilot_ch_6)
# Move to separate file and from original dataset -----------------------------
dat_adults <- extract_pilot_by_vpid(
dat_adults, out_path = file.path(out_path, "pilots"), export_csv = FALSE,
pilot_ids = pilot_ad_all, sample = "adults", vpid_col = "vpid"
)
dat_adolescents <- extract_pilot_by_vpid(
dat_adolescents, out_path = file.path(out_path, "pilots"), export_csv = FALSE,
pilot_ids = pilot_asc_all, sample = "adolescents", vpid_col = "vpid"
)
dat_children_parents <- extract_pilot_by_vpid(
dat_children_parents, out_path = file.path(out_path, "pilots"), export_csv = FALSE,
pilot_ids = pilots_ch_all, sample = "children_parents", vpid_col = "vpid"
)
dat_children_p6 <- extract_pilot_by_vpid(
dat_children_p6, out_path = file.path(out_path, "pilots"), export_csv = FALSE,
pilot_ids = pilots_ch_all, sample = "children_p6", vpid_col = "VPCode"
)
dat_parents_p6 <- extract_pilot_by_vpid(
dat_parents_p6, out_path = file.path(out_path, "pilots"), export_csv = FALSE,
pilot_ids = pilots_ch_all, sample = "parents_p6", vpid_col = "VPCode"
)
# Handle duplicate IDs ---------------------------------------------------------
# Delete not needed, incomplete or faulty datasets
# Project 3
del_id_ad <- c(59, 80) # Hendrik said they can be deleted as they are incomplete
dat_adults <- dat_adults %>%
dplyr::filter(!id %in% del_id_ad)
# Project 6
keep_row_id <- dat_children_parents %>%
mutate(start_dt = as.POSIXct(startdate), .row = row_number()) %>%
filter(vpid == 62128, form == "C") %>%
arrange(start_dt, .row) %>%
slice_head(n = 1) %>%
pull(.row)
dat_children_parents <- dat_children_parents %>%
mutate(.row = row_number()) %>%
filter(.row == keep_row_id | !(vpid == 62128 & form == "C")) %>%
select(-.row)
# Project 8
dat_children_parents <- dat_children_parents %>%
mutate(startdate = as.Date(startdate)) %>%
group_by(vpid, form) %>%
filter(!(vpid == 80505 & form == "P" & startdate == max(startdate))) %>%
ungroup()
# Auto-remove and check for remaining duplicates
# Adults
res_adults <- resolve_duplicates(dat_adults, vp_col, submit_col,
dataset_name = "adults", data_type = "questionnaire",
project_col, logger = logger)
dat_adults    <- res_adults$cleaned
trash_adults  <- res_adults$trash_bin
# [adults] Multiple complete datasets for vpid=80009 — please resolve manually.
# [adults] Multiple complete datasets for vpid=80011 — please resolve manually.
# Adolescents
res_adolescents <- resolve_duplicates(dat_adolescents, vp_col, submit_col,
dataset_name = "adolescents", data_type = "questionnaire",
project_col, logger = logger)
dat_adolescents   <- res_adolescents$cleaned
trash_adolescents <- res_adolescents$trash_bin
# [adolescents] Multiple complete datasets for vpid=70076 — please resolve manually.
# [adolescents] Multiple complete datasets for vpid=70072 — please resolve manually.
# [adolescents] Multiple complete datasets for vpid=70062 — please resolve manually.
# Children/Parents
res_children_parents <- resolve_duplicates(dat_children_parents, vp_col, submit_col,
dataset_name = "children_parents", data_type = "questionnaire",
project_col, logger = logger)
dat_children_parents  <- res_children_parents$cleaned
trash_children_parents<- res_children_parents$trash_bin
# Project 6 children parents
vp_col <- "VPCode"
res_children_p6 <- resolve_duplicates(dat_children_p6, vp_col, submit_col,
dataset_name = "children_p6", data_type = "questionnaire",
project_col, lastpage_threshold = 13, logger = logger)
dat_children_p6 <- res_children_p6$cleaned
trash_children_p6 <- res_children_p6$trash_bin
res_parents_p6 <- resolve_duplicates(dat_parents_p6, vp_col, submit_col,
dataset_name = "parents_p6", data_type = "questionnaire",
project_col, lastpage_threshold = 13, logger = logger)
dat_parents_p6 <- res_parents_p6$cleaned
trash_parents_p6 <- res_parents_p6$trash_bin
# Special Case Project 8: Check C, P and A entries -----------------------------
check_vpid_forms(dat_children_parents, logger = logger)
# Save the Trash just to be safe -----------------------------------------------
all_trash_adults      <- rbind(all_empty_ad, trash_adults)
all_trash_children    <- rbind(all_empty_ch, trash_children_parents)
all_trash_adolescents <- rbind(empty_adlsc_7, trash_adolescents)
write_xlsx(all_trash_adults,      file.path(out_path, "discarded", sprintf("deleted-rows_%s_adults.xlsx", today)))
write_xlsx(all_trash_children,    file.path(out_path, "discarded", sprintf("deleted-rows_%s_children.xlsx", today)))
write_xlsx(all_trash_adolescents, file.path(out_path, "discarded", sprintf("deleted-rows_%s_adolescents.xlsx", today)))
# Separate the data by project and store on disk -------------------------------
# Questionnaires
separate_by_project(dat_adults,           out_path, "adults",          data_type = "questionnaires", metadata_info = quest_info)
separate_by_project(dat_adolescents,      out_path, "adolescents",     data_type = "questionnaires", metadata_info = quest_info)
separate_by_project(dat_children_parents, out_path, "children",        data_type = "questionnaires", metadata_info = quest_info)
separate_by_project(dat_children_p6,      out_path, "children_p6",     data_type = "questionnaires", metadata_info = quest_info)
separate_by_project(dat_parents_p6,       out_path, "parents_p6",      data_type = "questionnaires", metadata_info = quest_info)
##########################################################################
## Data Cleaning for Cognitive Test Data ---------------------------------
##########################################################################
# Set column name variables ----------------------------------------------------
vp_col     <- "id"
project_col<- "p"
# last_page <- "lastpage"
link_col   <- "comp"
id_col     <- NA    # psytoolkit info sheets: vpid; questionnaires: unique increment counter
submit_col <- "TIME_end"
start_col  <- "TIME_start"
# Fix issues with project assignment ------------------------------------------
psytool_info_adults[[project_col]][which(psytool_info_adults[[vp_col]] == 2048)]  <- 2
psytool_info_adults[[project_col]][which(psytool_info_adults[[vp_col]] == 99017)] <- 9
# Remove empty Rows ------------------------------------------------------------
list_output           <- partition_empty_obs_psytoolkit(psytool_info_adults)
psytool_info_adults   <- list_output$kept
no_id_ad              <- list_output$no_id
empty_rows_ad         <- list_output$empty
# TODO: need to understand how it is possible to generate entries without ID - and possibly reconstruct?
list_output               <- partition_empty_obs_psytoolkit(psytool_info_adolescents)
psytool_info_adolescents  <- list_output$kept
no_id_adlsc               <- list_output$no_id
empty_rows_adlsc          <- list_output$empty
list_output            <- partition_empty_obs_psytoolkit(psytool_info_children)
psytool_info_children  <- list_output$kept
no_id_ch               <- list_output$no_id
empty_rows_ch          <- list_output$empty
# Fix ID naming issues ---------------------------------------------------------
# Project 2
PROJECT <- 2
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 20035)] <- 20036
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 4    & psytool_info_adults[[project_col]] == PROJECT)] <- 20004
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 6    & psytool_info_adults[[project_col]] == PROJECT)] <- 20006
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 15   & psytool_info_adults[[project_col]] == PROJECT)] <- 20015
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 2023 & psytool_info_adults[[project_col]] == PROJECT)] <- 20023
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 26   & psytool_info_adults[[project_col]] == PROJECT)] <- 20026
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 35   & psytool_info_adults[[project_col]] == PROJECT)] <- 20035
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 2041 & psytool_info_adults[[project_col]] == PROJECT)] <- 20041
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 2044 & psytool_info_adults[[project_col]] == PROJECT)] <- 20044
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 2046 & psytool_info_adults[[project_col]] == PROJECT)] <- 20046
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 2048 & psytool_info_adults[[project_col]] == PROJECT)] <- 20048
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 2051 & psytool_info_adults[[project_col]] == PROJECT)] <- 20051
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 2052 & psytool_info_adults[[project_col]] == PROJECT)] <- 20052
# Project 3
PROJECT <- 3
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 1 & psytool_info_adults[[project_col]] == PROJECT)] <- 30001
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 3 & psytool_info_adults[[project_col]] == PROJECT)] <- 30003
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 8 & psytool_info_adults[[project_col]] == PROJECT)] <- 30008
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 9 & psytool_info_adults[[project_col]] == PROJECT)] <- 30009
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 10002 & psytool_info_adults[[project_col]] == PROJECT)] <- 30002
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 10005 & psytool_info_adults[[project_col]] == PROJECT)] <- 30005
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 10006 & psytool_info_adults[[project_col]] == PROJECT)] <- 30006
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 10007 & psytool_info_adults[[project_col]] == PROJECT)] <- 30007
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 40019 & psytool_info_adults[[project_col]] == PROJECT)] <- 30019
# Falsely named datasets -----------------------------
psytool_info_adults$id <- suppressWarnings(as.integer(psytool_info_adults$id))
psytool_info_adults <- psytool_info_adults %>%
group_by(id) %>%
mutate(
id = dplyr::case_when(
id == 30048L & p == 3 & TIME_start == max(TIME_start) ~ 30047L,
id == 30058L & p == 3 & TIME_start == max(TIME_start) ~ 30057L,
TRUE ~ id
)
) %>%
ungroup()
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 219 & psytool_info_adults[[project_col]] == PROJECT)] <- 30002
# Project 4
PROJECT <- 4
# assuming a 0 (or many) 0s are missing
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 4001 & psytool_info_adults[[project_col]] == PROJECT)] <- 40001
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 4002 & psytool_info_adults[[project_col]] == PROJECT)] <- 40002
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 4003 & psytool_info_adults[[project_col]] == PROJECT)] <- 40003
# Project 8
PROJECT <- 8
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 800028 & psytool_info_adults[[project_col]] == PROJECT)] <- 80028
# Project 9
PROJECT <- 9
psytool_info_adults[[vp_col]][which(psytool_info_adults[[vp_col]] == 9901)] <- 99001
# Special Case Project 8: Remap VPIDs so children and adults have unique IDs --
psytool_info_children <- correct_child_vpids(
psytool_info_children, vpid_col = "id", project_col = "p",  startdate_col = "TIME_start",
mapping_file = file.path("information", "2025-08-19_Neuzuordnung_VP-IDs_Kinder-Sample_Projekt_8.xlsx")
)
# Gather Pilot Participant IDs -------------------------------------------------
pilots_ad_auto  <- find_pilot_ids(dat_general, psytool_info_adults,      vpid_col_df2 = vp_col)
pilots_asc_auto <- find_pilot_ids(dat_general, psytool_info_adolescents, vpid_col_df2 = vp_col)
pilots_ch_auto  <- find_pilot_ids(dat_general, psytool_info_children,    vpid_col_df2 = vp_col)
pilot_ad_2  <- c(20004)
pilot_ad_9  <- c()
pilot_ad_8  <- c(80350)
pilot_asc_7 <- c()
pilot_ch_6  <- c(62973, 62980, 62998, 62992, 62987, 62989, 62994, 62970)
pilot_ad_all  <- c(pilot_ad_2, pilot_ad_9, pilot_ad_8, pilots_ad_auto)
pilot_asc_all <- c(pilots_asc_auto)
pilots_ch_all <- c(pilots_ch_auto, pilot_ch_6)
# Move to separate file and from original dataset -----------------------------
psytool_info_adults <- extract_pilot_by_vpid(
psytool_info_adults, out_path = file.path(out_path, "pilots"), export_csv = FALSE,
pilot_ids = pilot_ad_all, sample = "psytool_adults", vpid_col = vp_col
)
psytool_info_adolescents <- extract_pilot_by_vpid(
psytool_info_adolescents, out_path = file.path(out_path, "pilots"), export_csv = FALSE,
pilot_ids = pilot_asc_all, sample = "psytool_adolescents", vpid_col = vp_col
)
psytool_info_children <- extract_pilot_by_vpid(
psytool_info_children, out_path = file.path(out_path, "pilots"), export_csv = FALSE,
pilot_ids = pilots_ch_all, sample = "psytool_children", vpid_col = vp_col
)
# Handle duplicate IDs ---------------------------------------------------------
# Delete not needed, incomplete or faulty datasets -----------------------------
# Project 3 — Hendrik said they can be deleted
psytool_info_adults <- psytool_info_adults %>%
group_by(.data[[vp_col]]) %>%
filter(!(.data[[vp_col]] == 30009 & .data[[start_col]] != max(.data[[start_col]]))) %>%
ungroup()
# Adults
res_adults <- resolve_duplicates(psytool_info_adults, vp_col, submit_col,
dataset_name = "adults", data_type = "experiment_data",
project_col, logger = logger)
psytool_info_adults <- res_adults$cleaned
trash_adults        <- res_adults$trash_bin
# ⚠️ [adults] Multiple complete datasets for id=30099 — please resolve manually.
# Adolescents
res_adolescents <- resolve_duplicates(psytool_info_adolescents, vp_col, submit_col,
dataset_name = "adolescents", data_type = "experiment_data",
project_col, logger = logger)
psytool_info_adolescents <- res_adolescents$cleaned
trash_adolescents        <- res_adolescents$trash_bin
# Children
res_children <- resolve_duplicates(psytool_info_children, vp_col, submit_col,
dataset_name = "children", data_type = "experiment_data",
project_col, logger = logger)
psytool_info_children <- res_children$cleaned
trash_children        <- res_children$trash_bin
# Separate the data by project and store on disk -------------------------------
# Cognitive Tests
adult_paths      <- separate_by_project(psytool_info_adults,      cogtest_out_path, "adults",
data_type = "experiment_data", metadata_info = cogtest_info)
children_paths   <- separate_by_project(psytool_info_children,    cogtest_out_path, "children_parents",
data_type = "experiment_data", metadata_info = cogtest_info)
adolescents_paths<- separate_by_project(psytool_info_adolescents, cogtest_out_path, "adolescents",
data_type = "experiment_data", metadata_info = cogtest_info)
path_components     <- unlist(strsplit(adult_paths[1], .Platform$file.sep))
path_length         <- length(path_components)
all_path_components <- unlist(strsplit(adult_paths, .Platform$file.sep))
# given: all_path_components (character vector), path_length (integer)
n <- floor(length(all_path_components) / path_length)
stopifnot(n > 0)
# reshape components into rows of length `path_length`
m <- matrix(all_path_components[seq_len(n * path_length)], nrow = n, byrow = TRUE)
# everything except the last element of each row
proj_folders <- m[, 1:(path_length - 1), drop = FALSE]
# first character of the (path_length-1)-th element in each row
proj_numbers <- substr(m[, path_length - 1], 1, 1)
# 1) Collapse each row of components into a full folder path
project_folder <- apply(proj_folders, 1, function(parts) do.call(file.path, as.list(parts)))
# 2) Make sure the first-digit keys are character
proj_keys <- as.character(proj_numbers)
# 3) Build the named character vector for logger$split()
dest_dirs <- stats::setNames(project_folder, proj_keys)
# Step 4: remove existing .log files if they exist
for (dir in dest_dirs) {
if (dir.exists(dir)) {
log_files <- list.files(dir, pattern = "\\.log$", full.names = TRUE)
if (length(log_files) > 0) {
message("Removing existing log files in: ", dir)
file.remove(log_files)
}
}
}
logger$split(dest_dirs)
# 4️⃣ Close when done
logger$close()
## Get the Experimental Data Sets Associated with the project ------------------
copy_psytool_files(cogtest_out_path = out_path, meta_env_name = "cogtest_info")
## Print the final list of IDs to Disk -----------------------------------------
collect_ids_to_excel(
meta_data = quest_info,
dat_adults,
dat_adolescents,
dat_children_parents,
dat_children_p6,
dat_parents_p6,
id_col = "vpid",
project_col = "project",
data_type = "questionnaire"
)
#!/usr/bin/env Rscript
suppressPackageStartupMessages({
library(readxl)
library(openxlsx)   # for writing multi-sheet Excel
library(dplyr)
library(stringr)
library(purrr)
library(tidyr)
})
#!/usr/bin/env Rscript
# Install/load packages --------------------------------------------------------
suppressPackageStartupMessages({
if (!require("dplyr"))     { install.packages("dplyr")      }; library(dplyr)
if (!require("tidyr"))     { install.packages("tidyr")      }; library(tidyr)
if (!require("readxl"))    { install.packages("readxl")     }; library(readxl)
if (!require("openxlsx"))  { install.packages("openxlsx")   }; library(openxlsx)
if (!require("purrr"))     { install.packages("purrr")      }; library(purrr)
if (!require("stringr"))   { install.packages("stringr")    }; library(openxlsx)
})
# -------------------- Helpers & Config --------------------
get_script_dir <- function() {
args <- commandArgs(trailingOnly = FALSE)
file_arg <- "--file="
path <- sub(file_arg, "", args[grepl(file_arg, args)])
if (length(path)) dirname(normalizePath(path)) else getwd()
}
SCRIPT_DIR <- get_script_dir()
DATA_DIR   <- file.path(SCRIPT_DIR, "private_information")
PROJ_ROOT  <- file.path(SCRIPT_DIR, "01_project_data")
if (!dir.exists(DATA_DIR)) stop("Directory not found: ", DATA_DIR)
# Ensure project root exists (we'll create subfolders as needed)
if (!dir.exists(PROJ_ROOT)) dir.create(PROJ_ROOT, recursive = TRUE, showWarnings = FALSE)
TYPES <- c("cogtest", "questionnaire", "questionnaire_p6")
FILENAME_RE <- "^(.*?)_ids_in_all_projects_(cogtest|questionnaire|questionnaire_p6)\\.xlsx$"
RE_COG  <- "^(?:psytool_info|cogtest)_([A-Za-z0-9_]+)_([1-9])$"
RE_Q    <- "^(?:dat|questionnaire)_([A-Za-z0-9_]+)_([1-9])$"
RE_QP6  <- "^(?:dat|questionnaire)_([A-Za-z0-9_]+)_p([1-9])$"
normalize_sample <- function(s) {
s <- tolower(trimws(s))
if (s %in% c("children_parents", "parents")) return("children")
s
}
parse_date_tag <- function(tag) {
fmts <- c("%Y-%m-%d", "%Y%m%d", "%d-%m-%Y", "%Y.%m.%d")
for (fmt in fmts) {
dt <- try(as.POSIXct(tag, format = fmt, tz = "UTC"), silent = TRUE)
if (!inherits(dt, "try-error") && !is.na(dt)) {
return(list(key = as.numeric(dt), norm = format(dt, "%Y-%m-%d")))
}
}
if (grepl("^[0-9]+$", tag)) return(list(key = as.numeric(tag), norm = tag))
list(key = NA_real_, norm = tag)
}
# -------------------- Discover latest files --------------------
files <- list.files(DATA_DIR, pattern = "_ids_in_all_projects_.*\\.xlsx$", full.names = TRUE)
if (!length(files)) stop("No matching files in ", DATA_DIR)
meta <- tibble(
path = files,
name = basename(files)
) %>%
mutate(m = str_match(name, FILENAME_RE)) %>%
filter(!is.na(m[,1])) %>%
transmute(
path,
dtype = tolower(m[,3]),
date_tag = m[,2]
) %>%
rowwise() %>%
mutate(
parsed = list(parse_date_tag(date_tag)),
date_key = parsed$key,
date_norm = parsed$norm
) %>%
ungroup()
if (!nrow(meta)) stop("No files matched the expected naming pattern.")
coverage <- meta %>%
group_by(date_norm) %>%
summarize(
types_present = n_distinct(dtype),
max_key = max(coalesce(date_key, -Inf)),
.groups = "drop"
) %>%
arrange(desc(types_present), desc(max_key))
best_norm <- coverage$date_norm[1]
chosen <- meta %>%
filter(date_norm == best_norm) %>%
group_by(dtype) %>%
slice_max(order_by = coalesce(date_key, -Inf), with_ties = FALSE) %>%
ungroup()
if (!"cogtest" %in% chosen$dtype) {
newest_cog <- meta %>%
filter(dtype == "cogtest") %>%
slice_max(order_by = coalesce(date_key, -Inf), with_ties = FALSE)
if (!nrow(newest_cog)) stop("Could not find any cogtest file.")
chosen <- bind_rows(chosen, newest_cog)
}
message("Using files:")
chosen %>%
arrange(factor(dtype, levels = TYPES)) %>%
{ purrr::pwalk(list(..1=.$path, ..2=.$dtype), ~ message("  - ", ..2, ": ", basename(..1))) }
paths <- setNames(chosen$path, chosen$dtype)
# ---- capture the exact date tag from the chosen cogtest file for filenames ----
cog_date_tag <- chosen %>% filter(dtype == "cogtest") %>% pull(date_tag) %>% .[1]
if (is.na(cog_date_tag) || length(cog_date_tag) == 0) {
# fall back to normalized date if needed
cog_date_tag <- chosen %>% filter(dtype == "cogtest") %>% pull(date_norm) %>% .[1]
}
# -------------------- Load and extract IDs per (sample, project) --------------------
read_if <- function(dtype) if (dtype %in% names(paths)) readxl::read_excel(paths[[dtype]]) else NULL
collect_ids_from_cols <- function(df, pattern, map_project = identity, sample_normalizer = normalize_sample) {
if (is.null(df)) return(list())
out <- list()
for (cn in names(df)) {
if (!is.character(cn)) next
m <- str_match(cn, pattern)
if (is.na(m[1,1])) next
sample <- sample_normalizer(m[1,2])
project <- as.integer(map_project(m[1,3]))
ids <- df[[cn]] %>% as.character() %>% trimws() %>% .[!is.na(.) & . != ""]
key <- paste(sample, project, sep = "|")
if (!length(ids)) next
if (is.null(out[[key]])) out[[key]] <- unique(ids) else out[[key]] <- union(out[[key]], ids)
}
out
}
cog_df  <- read_if("cogtest")
q_df    <- read_if("questionnaire")
qp6_df  <- read_if("questionnaire_p6")
cog_map <- collect_ids_from_cols(cog_df, RE_COG)
q_map   <- collect_ids_from_cols(q_df, RE_Q)
qp6_map <- collect_ids_from_cols(qp6_df, RE_QP6, map_project = function(x) as.integer(x))
merge_maps <- function(a, b) {
keys <- union(names(a), names(b))
out <- vector("list", length(keys)); names(out) <- keys
for (k in keys) out[[k]] <- union(a[[k]] %||% character(), b[[k]] %||% character())
out
}
`%||%` <- function(x, y) if (is.null(x)) y else x
q_all <- merge_maps(q_map, qp6_map)
valid_key <- function(k) {
parts <- strsplit(k, "\\|")[[1]]
if (length(parts) != 2) return(FALSE)
p <- suppressWarnings(as.integer(parts[2]))
!is.na(p) && p >= 1 && p <= 9
}
all_keys <- union(names(cog_map), names(q_all))
all_keys <- all_keys[vapply(all_keys, valid_key, logical(1))]
all_keys <- sort(all_keys)
rows_complete <- list()
rows_missing_q <- list()
rows_missing_c <- list()
for (k in all_keys) {
parts <- strsplit(k, "\\|")[[1]]
sample <- parts[1]; project <- as.integer(parts[2])
cog_ids <- cog_map[[k]] %||% character()
q_ids   <- q_all[[k]]   %||% character()
complete   <- intersect(cog_ids, q_ids)
missing_q  <- setdiff(cog_ids, q_ids)
missing_c  <- setdiff(q_ids, cog_ids)
if (length(complete))     rows_complete[[k]] <- tibble(sample, project, id = sort(unique(complete)))
if (length(missing_q))    rows_missing_q[[k]] <- tibble(sample, project, id = sort(unique(missing_q)))
if (length(missing_c))    rows_missing_c[[k]] <- tibble(sample, project, id = sort(unique(missing_c)))
}
df_complete <- if (length(rows_complete)) bind_rows(rows_complete) else tibble(sample=character(), project=integer(), id=character())
df_miss_q   <- if (length(rows_missing_q)) bind_rows(rows_missing_q) else tibble(sample=character(), project=integer(), id=character())
df_miss_c   <- if (length(rows_missing_c)) bind_rows(rows_missing_c) else tibble(sample=character(), project=integer(), id=character())
# -------------------- Write OVERVIEW workbook (date-prefixed) --------------------
overview_name <- sprintf("%s_id_completeness_report.xlsx", cog_date_tag)
overview_path <- file.path(DATA_DIR, overview_name)
openxlsx::write.xlsx(
list(
complete = df_complete,
missing_questionnaire = df_miss_q,
missing_cogtest = df_miss_c
),
file = overview_path,
overwrite = TRUE
)
# -------------------- Write per-project subtables into 01_project_data/<n>_backbone --------------------
write_project_workbook <- function(prj, df_complete, df_miss_q, df_miss_c) {
sub_complete <- df_complete %>% filter(project == prj)
sub_miss_q   <- df_miss_q   %>% filter(project == prj)
sub_miss_c   <- df_miss_c   %>% filter(project == prj)
# Destination folder
prj_dir <- file.path(PROJ_ROOT, sprintf("%d_backbone", prj))
if (!dir.exists(prj_dir)) dir.create(prj_dir, recursive = TRUE, showWarnings = FALSE)
prj_name <- sprintf("%s_project_%d_id_completeness.xlsx", cog_date_tag, prj)
prj_path <- file.path(prj_dir, prj_name)
wb <- createWorkbook()
addWorksheet(wb, "complete")
addWorksheet(wb, "missing_questionnaire")
addWorksheet(wb, "missing_cogtest")
writeData(wb, "complete", sub_complete)
writeData(wb, "missing_questionnaire", sub_miss_q)
writeData(wb, "missing_cogtest", sub_miss_c)
saveWorkbook(wb, prj_path, overwrite = TRUE)
invisible(prj_path)
}
prj_paths <- lapply(1:9, write_project_workbook, df_complete=df_complete, df_miss_q=df_miss_q, df_miss_c=df_miss_c)
# -------------------- Console summary --------------------
summarize_counts <- function(df) {
if (!nrow(df)) return("—")
df %>%
count(sample, project, name = "n") %>%
arrange(sample, project) %>%
mutate(txt = paste0(sample, " / ", project, ": ", n)) %>%
pull(txt) %>%
paste(collapse = "; ")
}
cat("Overview written to:", overview_path, "\n\n")
cat("Counts per (sample, project):\n")
cat("  complete:              ", summarize_counts(df_complete), "\n", sep = "")
cat("  missing_questionnaire: ", summarize_counts(df_miss_q),   "\n", sep = "")
cat("  missing_cogtest:       ", summarize_counts(df_miss_c),   "\n", sep = "")
cat("\nProject workbooks:\n")
for (i in seq_along(prj_paths)) cat("  - ", prj_paths[[i]], "\n", sep = "")
cat("\nUsing files:\n")
chosen %>%
arrange(factor(dtype, levels = TYPES)) %>%
mutate(line = paste0("  - ", dtype, ": ", basename(path))) %>%
pull(line) %>%
cat(paste0(., collapse = "\n"), "\n")

# General rule: any column that ends in [digits] is treated as an item column
# (covers IDAS[001], APS[010], AQ[005], CAPEfreq[002], CAPEdistr[002], MAPA2[007], etc.)
grepl("\\[\\d+\\]$", nm)
}
rename_master_item_columns_inplace <- function(df) {
old <- names(df)
new <- old
idx <- vapply(old, is_item_like_col, logical(1))
new[idx] <- vapply(old[idx], normalize_master_item_id, character(1))
# Make sure names are unique after normalization
new <- make.unique(new, sep = "_dup")
map_tbl <- tibble::tibble(old = old, new = new, renamed = old != new)
names(df) <- new
list(df = df, map = map_tbl)
}
export_per_project <- function(df_clean, df_discard, sample, delim = ";") {
out_dir <- fs::path(DIR_EXPORT, sample)
fs::dir_create(out_dir)
# ---- PATCH: normalize item column names BEFORE writing master ----
ren <- rename_master_item_columns_inplace(df_clean)
df_clean <- ren$df
map_tbl  <- ren$map
# Optional: write mapping for audit/debug (recommended)
ts <- format(Sys.time(), "%Y-%m-%d_%H%M%S")
map_path <- fs::path(out_dir, glue::glue("rename_map_master_items_{sample}_{ts}.csv"))
readr::write_csv(map_tbl, map_path)
log_msg("Wrote rename map: ", map_path, "  (renamed n=", sum(map_tbl$renamed), ")")
# Master + discarded
master_path <- fs::path(out_dir, glue::glue("{sample}_clean_master.csv"))
disc_path   <- fs::path(out_dir, glue::glue("{sample}_discarded.csv"))
write.csv2(df_clean,   master_path, row.names = FALSE)
write.csv2(df_discard, disc_path,   row.names = FALSE)
log_msg("Wrote master (normalized items): ", master_path)
log_msg("Wrote discarded: ", disc_path)
# Per-project split (uses the normalized df_clean that was just written)
proj_col <- get_project_col(df_clean)
if (is.null(proj_col)) {
log_msg("No project column ('project' or 'p') â€” skipping per-project split.")
return(invisible(NULL))
}
df_split <- split(df_clean, df_clean[[proj_col]])
purrr::iwalk(df_split, function(dd, proj) {
safe_proj <- gsub("[^A-Za-z0-9_-]+", "_", proj)
filepath  <- fs::path(out_dir, glue::glue("{sample}_project-{safe_proj}_clean.csv"))
write_excel_friendly_csv(dd, filepath, delim)
})
log_msg(glue::glue("Exported {length(df_split)} CSVs with BOM + sep='{delim}' for '{sample}'."))
}
save_keys <- function(keys, sample) {
path_rds  <- fs::path(DIR_KEYS, glue::glue("{sample}_keys.rds"))
path_json <- fs::path(DIR_KEYS, glue::glue("{sample}_keys.json"))
saveRDS(keys, path_rds)
jsonlite::write_json(keys, path_json, pretty = TRUE, auto_unbox = TRUE)
log_msg(glue::glue("Saved keys for '{sample}' to: {path_rds} and {path_json}"))
}
# ---- Demographics & Health utilities -----------------------------------------
# FIXED: no tidyselect misuse; guard all columns safely
label_demographics_health <- function(df) {
out <- df
# Gender-like columns
gender_cols <- intersect(
c("gender",
grep("^parentsgender|^siblingsgender|^cildrengender|^childrengender|^children(gender)?",
names(out), value = TRUE, ignore.case = TRUE)),
names(out)
)
if (length(gender_cols)) {
out <- out %>%
dplyr::mutate(
dplyr::across(
dplyr::all_of(gender_cols),
~ factor(as.character(.x),
levels = c("1","2","3","0","-oth-"),
labels = c("female","male","nonbinary","no gender","other"))
)
)
}
# Education
if ("education" %in% names(out)) {
out <- out %>%
dplyr::mutate(
education = factor(as.character(education),
levels = c("0","1","2","3","4","5","6","7","8","9","10","-oth-"),
labels = c("no school diploma",
"primary school",
"Lower Secondary School Certificate",
"Intermediate Secondary School Certificate",
"General Qualification for University Entrance",
"apprentice",
"applied science (Fachhochschulabschluss)",
"diploma","bachelor","master","PhD","other"))
) %>%
dplyr::mutate(
education = forcats::fct_relevel(
education,
"no school diploma","primary school",
"Lower Secondary School Certificate","Intermediate Secondary School Certificate",
"General Qualification for University Entrance","apprentice",
"applied science (Fachhochschulabschluss)",
"bachelor","diploma","master","PhD","other"
),
education = factor(education, levels = levels(education), ordered = TRUE)
)
}
# Marital status
if ("maritalstat" %in% names(out)) {
out <- out %>%
dplyr::mutate(
maritalstat = factor(as.character(maritalstat),
levels = c("0","1","2","3","4"),
labels = c("single","relationship","married","divorced","widowed"))
)
}
# Eyesight / hearing (optional)
sens_cols <- intersect(c("eyesight","hearing"), names(out))
if (length(sens_cols)) {
out <- out %>%
dplyr::mutate(
dplyr::across(
dplyr::all_of(sens_cols),
~ factor(as.character(.x),
levels = c("0","1","2"),
labels = c("normal","corrected","not corrected"))
)
)
}
# Binary health/contact flags (optional)
bin_candidates <- c("psychomedication","othermedication","ownpsychdisorder")
bin_candidates <- union(bin_candidates, grep("contact", names(out), value = TRUE))
bin_cols <- intersect(bin_candidates, names(out))
if (length(bin_cols)) {
out <- out %>% dplyr::mutate(
dplyr::across(dplyr::all_of(bin_cols),
~ factor(as.character(.x), levels = c("0","1"), labels = c("no","yes")))
)
}
out
}
# ---- Central enrichment (single source of truth) -----------------------------
enrich_demographics_and_health_fields <- function(df, sample) {
d <- label_demographics_health(df)
# ---- helpers ----
parse_date_safely <- function(x) suppressWarnings(as.Date(x))
# Prefer start date; fall back to datestamp; do NOT fall back to Sys.Date()
get_start_like_date <- function(z) {
cand <- intersect(c("startdate", "datestamp"), names(z))
if (!length(cand)) return(rep(as.Date(NA), nrow(z)))
# pick the first that exists
parse_date_safely(z[[cand[1]]])
}
looks_like_years_vec <- function(x) {
xn <- suppressWarnings(as.numeric(x))
# "looks like years" when most non-missing values are <= 120
if (all(is.na(xn))) return(FALSE)
stats::median(xn, na.rm = TRUE) <= 120
}
# ---- age computation ----
dob   <- if ("age" %in% names(d)) parse_date_safely(d$age) else as.Date(NA)
start <- get_start_like_date(d)
age_num_raw <- if ("age" %in% names(d)) suppressWarnings(as.numeric(d$age)) else rep(NA_real_, nrow(d))
treat_as_years <- looks_like_years_vec(d$age)
d <- d %>%
dplyr::mutate(
age_years = dplyr::case_when(
# PRIMARY RULE: age column contains a date (DOB) AND we have a start date
!is.na(dob) & !is.na(start) ~ as.integer(floor(lubridate::interval(dob, start) / lubridate::years(1))),
# SECONDARY RULE: if the age column is numeric "in years", accept it as-is
treat_as_years ~ as.integer(floor(age_num_raw)),
TRUE ~ NA_integer_
),
height = suppressWarnings(as.numeric(.data[["height"]])),
weight = suppressWarnings(as.numeric(.data[["weight"]]))
)
# ---- sanity thresholds + logging ----
get_id_vec <- function(z) {
if ("vpid" %in% names(z)) z$vpid
else if ("vp" %in% names(z)) z$vp
else if ("participantid" %in% names(z)) z$participantid
else rep(NA_character_, nrow(z))
}
proj_col <- get_project_col(d)
id_vec <- get_id_vec(d)
# Adults: raise sensible minimum age to 18 years
if (tolower(sample) == "adults") {
age_bad    <- !is.na(d$age_years) & d$age_years < 18L
height_bad <- !is.na(d$height)    & d$height > 250
weight_bad <- !is.na(d$weight)    & d$weight < 35
rep_rows <- function(idx, var, values, rule) {
if (any(idx, na.rm = TRUE)) {
tibble::tibble(
vpid = id_vec[idx],
p    = if (!is.null(proj_col)) d[[proj_col]][idx] else NA_character_,
value = values[idx]
) %>% log_sanity(sample, ., var, rule)
}
}
rep_rows(age_bad,    "age",    d$age_years, "below sensible threshold 18 years (adults)")
rep_rows(height_bad, "height", d$height,    "above sensible threshold 250 cm")
rep_rows(weight_bad, "weight", d$weight,    "below sensible threshold 35 kg")
d <- d %>%
dplyr::mutate(
age_years = dplyr::if_else(age_bad,    as.integer(NA), age_years),
height    = dplyr::if_else(height_bad, NA_real_,       height),
weight    = dplyr::if_else(weight_bad, NA_real_,       weight)
)
} else if (tolower(sample) == "adolescents") {
# keep the old adolescent thresholds
age_bad    <- !is.na(d$age_years) & d$age_years < 5L
height_bad <- !is.na(d$height)    & d$height > 250
weight_bad <- !is.na(d$weight)    & d$weight < 35
rep_rows <- function(idx, var, values, rule) {
if (any(idx, na.rm = TRUE)) {
tibble::tibble(
vpid = id_vec[idx],
p    = if (!is.null(proj_col)) d[[proj_col]][idx] else NA_character_,
value = values[idx]
) %>% log_sanity(sample, ., var, rule)
}
}
rep_rows(age_bad,    "age",    d$age_years, "below sensible threshold 5 years")
rep_rows(height_bad, "height", d$height,    "above sensible threshold 250 cm")
rep_rows(weight_bad, "weight", d$weight,    "below sensible threshold 35 kg")
d <- d %>%
dplyr::mutate(
age_years = dplyr::if_else(age_bad,    as.integer(NA), age_years),
height    = dplyr::if_else(height_bad, NA_real_,       height),
weight    = dplyr::if_else(weight_bad, NA_real_,       weight)
)
}
# ---- manual override: vpid 30102 -> age_years = NA ----
if (any(!is.na(id_vec))) {
idx_manual <- as.character(id_vec) %in% c("30102")
if (any(idx_manual, na.rm = TRUE)) {
tibble::tibble(
vpid = id_vec[idx_manual],
p    = if (!is.null(proj_col)) d[[proj_col]][idx_manual] else NA_character_,
value = d$age_years[idx_manual]
) %>% log_sanity(sample, ., "age", "manually set to NA due to implausible DOB (would be ~5 years in adults)")
d$age_years[idx_manual] <- NA_integer_
}
}
# ---- minimal recodes used downstream (unchanged) ----
if ("gender" %in% names(d)) {
g <- as.character(d$gender)
g[!(g %in% c("female","male"))] <- NA_character_
d$gender <- factor(g, levels = c("female","male"))
}
if ("education" %in% names(d)) {
e <- as.character(d$education)
e[e %in% c("other","missing")] <- NA_character_
lev <- setdiff(levels(d$education), c("other","missing"))
d$education <- factor(e, levels = lev, ordered = TRUE)
}
if ("maritalstat" %in% names(d)) {
m <- as.character(d$maritalstat)
ord <- c("single","relationship","married","divorced","widowed")
d$maritalstat <- factor(m, levels = ord, ordered = TRUE)
}
d
}
# Sanity logger ---------------------------------------------------------------
log_sanity <- function(sample, df_rows, var, rule_desc) {
if (nrow(df_rows) == 0) return(invisible(NULL))
cat("", file = SANITY_LOG_FILE, append = FALSE)
apply(df_rows, 1, function(r) {
msg <- glue::glue("ðŸ”º vpid {r[['vpid']]} (p={r[['p']]}, sample={sample}) has {var}={r[['value']]} â€” {rule_desc}.")
log_msg(msg)
cat(paste0(msg, "\n"), file = SANITY_LOG_FILE, append = TRUE)
})
invisible(TRUE)
}
# ---- One-sample driver ------------------------------------------
process_sample <- function(sample,
questionnaire_path = NULL,
iteminfo_path = NULL,
scoring_df = NULL,
drop_criteria_fun = remove_flagged_rows) {
